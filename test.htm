<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="./jquery-3.7.1.min.js"></script>
	<title>レールレイアウトシミュレーション</title>
    <style>
        canvas {
            border: 1px solid #000;background-color:#fcfcfc;
        }
		button{ height: 50px;
		}
		#main,#title {
  float: none;
	margin: 0px;
	padding: 0px;
}

#rightmenu {
	margin: 0px;
	overflow: auto;
	top: 0px;
	left: 0px;
}

#app {
/*	margin: 0px 0px 0px 260px;*/
  width: 800px;
	padding: 0px;
	border: 3px solid;
}

#copyright {
  text-align:right;
  margin-right:15px;
}

H1 {
	font-size: 200%;
	margin: 5px 5px 5px 5px;
	display: inline-block;
}

H2 {
	font-size: 140%;
	font-weight: bold;
	margin: 5px 5px 5px 5px;
  display: inline-block;
}

input{
  margin: 5px 2px 2px 2px;
}

hr{
  margin-right:20px;
}

em {
	font-weight: bold;
	color: #0000CC;
	font-style: normal;
}

.explain {
	margin-left: 10px;
}

#remainRail{
	font-size: 150%;
}

#congrat {
	font-size: 180%;
	color: #FF0000;
}

#btn_nxt{
  //visibility: hidden;
  z-index: 3;
}
#dataSelect,#railSelect,#railSelect2{
  border:1px solid black;font-size: 150%;
}
    </style>

 <script type="text/javascript">
        let rails = []; // レールの配列
		let joints = []; //ジョイント部の配列
		let canvas;
		let ctx;
		let iFullsizeCanvas = false;
		let iConpane = true;

		
	function init(){
        canvas = document.getElementById('railCanvas');
        ctx = canvas.getContext('2d');//console.log(ctx);
		
		CANVASWIDTH  = canvas.width;
		CANVASHEIGHT = canvas.height;
//画面ドラッグ関連
		canvasOffsetX = CANVASWIDTH /2;
		canvasOffsetY = CANVASHEIGHT/2;

		
		
		//マウスイベントの呼び出し
    // マウスクリック時の処理
    //canvas.addEventListener('mousedown', onDragStart);
	//ドラッグ時
    //canvas.addEventListener('mousemove', onDrag ,  false);
    // マウスクリック時の処理
    canvas.addEventListener('mousedown', onMouseStart);
	//ドラッグ時
    canvas.addEventListener('mousemove', onMouseMove ,  false);
	// マウスアップ時の処理
    canvas.addEventListener('mouseup', onDragEnd,  false);
	//マウスホイール
	canvas.addEventListener("wheel", onWheel,  false );
	// マウスダブルクリック時の処理
    canvas.addEventListener('dblclick', onDblClick ,  false);

//タッチパネル
	canvas.addEventListener('touchstart',  onTouchstart,  false);
	canvas.addEventListener('touchend',	onDragEnd,	false);
	canvas.addEventListener('touchmove',  onTouchMove,  false);

		initCourse();
        draw();

		resizeEvent();
		$(window).bind("resize",resizeEvent);

	
	}



	let CANVASWIDTH  = 750;
	let CANVASHEIGHT = 750;
//画面ドラッグ関連
	let isDraggingCanvas = false;
	let canvasOffsetX = CANVASWIDTH /2;
	let canvasOffsetY = CANVASHEIGHT/2;
	let drawScale = 1;
	let scale = 1;

//タッチ関連
	let preMouseX;
	let preMouseY;
	let prePinchDist;//タッチ時の最初のピンチ幅
	let preScale;//タッチ開始時の縮尺
	let touchcount = 0;

	let setTOdrawID = null;
//レールの寸法
	const BASE_LENGTH = 80;
	const BASE_WIDTH = 14;
	const JOINT_WIDTH = 4;
	const JOINT_LENGTH = 4;
	
	const DOUBLE_TRACK_DISTANCE_RATIO = 0.278;	
	const URAIL_RADIUS_RATIO = 0.62037;	
	const URAIL_CNCT_R_RATIO = 1.02351;	
	
//レールタイプ　R:右曲線L:左曲線S:直線　G:複線外側右曲線　N:複線外側左曲線
//H:1/2レール　Q:1/4レール　D:倍直線　J:ジョイントレール（1/6)
//"U"：Uターン（右）"V"：Uターン（左）"A"：複線幅（右）C：複線幅（左）X：Y字幅（右）"Z"：Y字幅（左）
//レールを追加するのに必要な改修箇所　レール配列にレールを追加する関数(②が必要）、起点（ｘ、ｙ、angle）に対応して描画する関数①、終点を計算する関数②、タッチポイントに対してタッチ判定する関数③ 
// addRail()にcaseを追加　	CalcRailEnd（）にcaseを追加　draw（）にcaseを追加　isPointOnRail（）にcaseを追加　
	
	
	const lineWidthArray = [BASE_WIDTH, 12, 6, 4];
	const colorArray = ["#000000", "#51b5ff", "#1970c1", "#51b5ff"];
	const colorArray2 = ["#000000", "#4195ff", "#1970c1", "#4195ff"];//外側曲線
	const colorArray3 = ["#19c170", "#51ffb5", "#19c170", "#51ffb5"]; // 別ルート
	const colorArray4 = ["#f1f1f1", "#e5e5e5", "#f1f1f1", "#e5e5e5"]; // 別ルート
	const colorArray5 = ["#000000", "#e56565", "#ffaaaa", "#e56565"]; // Uレール
	const EmcolorArray = ["#ff0000", "#ffaacc", "#ff0000", "#ffaacc"];

	var observ = null;

	let num_rail = 0;
	let dfx = 0;//マウスクリックと図形原点のずれ
	let dfy = 0;

	// 終点位置
	const INIT_X = 0;
	const INIT_Y = 0;
	let endX;
	let endY;
	
	// 終点の角度
	let endAngleDeg; // -Y軸０　時計回り

    let selectedRail = null; // 選択中のレール
	let LastselectedRail = null;	
	let closestJoitn = null; // 最も近いジョイント
	let showArrowSet = false;
	let isshowAlljoint = false; 
	const CONECT_LIMIT_D = 8.0; //自動接続させる距離

//データの保存とロード
	function save() {
		const selectedData = document.getElementById("dataSelect").value;
		const json = JSON.stringify(rails);
		localStorage.setItem(selectedData, json);
		document.getElementById("output").textContent = "データを保存しました";
	}

	function load() {
		const selectedData = document.getElementById("dataSelect").value;
		const storedJson = localStorage.getItem(selectedData);console.log(selectedData + " loaded");
		if(storedJson == null){rails = [];
		} else{rails = JSON.parse(storedJson);}
		renewAllJointCoord();
		num_rail = rails.length;
		draw();
		document.getElementById("output").textContent = "データを呼び出しました";
	}
 
	function clearData() {
		rails = []; // レールの配列
		joints = []; //ジョイント部の配列
		num_rail = 0;
		endX = 0;
		endY = 0;
		endAngleDeg = 0;
		draw();
	}



	function scaleReset(){
		scale = 1;drawScale=1.0;
		canvasOffsetX = CANVASWIDTH /2;
		canvasOffsetY = CANVASHEIGHT/2;

		ctx.restore();ctx.save();
		ctx.setTransform(1,0,0,1,0,0);
	}

//キャンバスを一回初期化して倍率とオフセットを設定する。
	function canvasSetScale(){
		ctx.restore();ctx.save();
		ctx.setTransform(1,0,0,1,0,0);
		ctx.translate(canvasOffsetX,canvasOffsetY);
		ctx.scale(drawScale, drawScale);	
	}




　

	function initCourse() {
		endX = INIT_X;
		endY = INIT_Y;
		endAngleDeg = 0;
	}

	function add_SP_Rail(IDselect){
		const selectedtype = document.getElementById(IDselect).value;
		addRail(selectedtype);
		return selectedtype;
	}

		//レールを追加
	function addRail(type){switch(type){
			case 'R':case 'L':
					addCurve(endX, endY,endAngleDeg,type,1.0);break;
			case 'S':
					addRectangle(endX, endY,endAngleDeg,type,1.0,0);break;
			case 'H'://1/2直線
					addRectangle(endX, endY,endAngleDeg,type,0.5,0);break;
			case 'Q'://1/4直線
					addRectangle(endX, endY,endAngleDeg,type,0.25,0);break;
			case 'D'://倍直線
					addRectangle(endX, endY,endAngleDeg,type,2.0,0);break;
			case 'G':case 'N'://外側曲線
					addCurve(endX, endY,endAngleDeg,type,1.0+DOUBLE_TRACK_DISTANCE_RATIO);break;
//"U"：Uターン（右）"V"：Uターン（左）"A"：複線幅（右）C：複線幅（左）X：Y字幅（右）"Z"：Y字幅（左）
			case 'A':
					addRectangle(endX, endY,endAngleDeg,type,1.0,DOUBLE_TRACK_DISTANCE_RATIO);break;
			case 'C':
					addRectangle(endX, endY,endAngleDeg,type,1.0, -DOUBLE_TRACK_DISTANCE_RATIO);break;
			case 'X':
					addRectangle(endX, endY,endAngleDeg,type,1.0, 0.25);break;
			case 'Z':
					addRectangle(endX, endY,endAngleDeg,type,1.0, -0.25);break;
			case 'U':case 'V':
					addUrail(endX,endY,endAngleDeg,type);break;
			}//console.log(num_rail);
			LastselectedRail=rails[rails.length-1];//console.log(LastselectedRail);

	}
		//レール端点を計算
	function CalcRailEnd(x,y,angle,type){
		switch(type){
			case 'R':case 'L':
					[ex,ey,eAngle] = CalcCurveEnd(x,y,angle,type,1.0);break;
			case 'S':
					[ex,ey,eAngle] = CalcStraightEnd(x,y,angle,1.0);break;
			case 'H':
					[ex,ey,eAngle] = CalcStraightEnd(x,y,angle,0.5);break;
			case 'Q':
					[ex,ey,eAngle] = CalcStraightEnd(x,y,angle,0.25);break;
			case 'D':
					[ex,ey,eAngle] = CalcStraightEnd(x,y,angle,2);break;
			case 'G': case 'N':
					[ex,ey,eAngle] = CalcCurveEnd(x,y,angle,type,1.0+DOUBLE_TRACK_DISTANCE_RATIO);break;
//"U"：Uターン（右）"V"：Uターン（左）"A"：複線幅（右）C：複線幅（左）X：Y字幅（右）"Z"：Y字幅（左）
			case 'A':
					[ex,ey,eAngle] = drawSlideRail(x,y,angle, 1.0, DOUBLE_TRACK_DISTANCE_RATIO,0,0);break;
			case 'C':
					[ex,ey,eAngle] = drawSlideRail(x,y,angle, 1.0, -DOUBLE_TRACK_DISTANCE_RATIO,0,0);break;
			case 'X':
					[ex,ey,eAngle] = drawSlideRail(x,y,angle, 1.0, 0.25,0,0);break;
			case 'Y':
					[ex,ey,eAngle] = drawSlideRail(x,y,angle, 1.0, -0.25,0,0);break;
			case 'U':case 'V':
					[ex,ey,eAngle] = drawURCurveRail(x,y,angle,type,0,0,0,0);break;

			default:console.log("no type");		
		}
		return [ex,ey,eAngle];
	}

        // 直線を追加
    function addRectangle(x, y,angle,type,ratio,slide_ratio) {
		const rail_id = num_rail++;
		const opp_angle = addDeg(angle, 180);
	    const rail = {x,y,angle,type,id:rail_id };
		const joint1 = {x,y,angle:opp_angle,id:rail_id,j_id:0};
	    rails.push(rail);
		joints.push(joint1);
//		if(slide_ratio == 0){
		[endX,endY,endAngleDeg]=drawSlideRail(x,y,angle, ratio, slide_ratio,0,0);
//		[endX,endY,endAngleDeg]=CalcStraightEnd(x,y,angle,ratio);
//		} else{
//		[endX,endY,endAngleDeg]=drawSlideRail(x,y,angle, ratio, slide_ratio,0);
//		}
		const joint2 = {x:endX,y:endY,angle,id:rail_id,j_id:1};
		joints.push(joint2);
    }
        // 曲線を追加
    function addCurve(x, y,angle,type,ratio) {
 		const rail_id = num_rail++;
		const opp_angle = addDeg(angle, 180);
	    const rail = {x,y,angle,type,id:rail_id };
		const joint1 = {x,y,angle:opp_angle,id:rail_id,j_id:0};
	    rails.push(rail);
		joints.push(joint1);
		[endX,endY,endAngleDeg] = CalcCurveEnd(x,y,angle,type,ratio);	     
 		const joint2 = {x:endX,y:endY,angle:endAngleDeg,id:rail_id,j_id:1};
		joints.push(joint2);
    }
	//Uターンレールを追加
	function addUrail(x,y,angle,type){
 		const rail_id = num_rail++;
		const opp_angle = addDeg(angle, 180);
	    const rail = {x,y,angle,type,id:rail_id };
		const joint1 = {x,y,angle:opp_angle,id:rail_id,j_id:0};
	    rails.push(rail);
		joints.push(joint1);
		[endX,endY,endAngleDeg] = drawURCurveRail(x,y,angle,type,0,0,0,0);console.log(endX);	     
 		const joint2 = {x:endX,y:endY,angle:endAngleDeg,id:rail_id,j_id:1};
		joints.push(joint2);

	}

	//ジョイントを描画
	function drawJoint(x,y,angle,head) {
		var deg_sin = Math.sin(angle * Math.PI / 180.0);
		var deg_cos = Math.cos(angle * Math.PI / 180.0);

		if(head){
			ctx.fillStyle = colorArray[1];
			ctx.beginPath();
			ctx.moveTo(x + JOINT_WIDTH * 0.5 * deg_cos  ,  y + JOINT_WIDTH  * 0.5 * deg_sin );
			ctx.lineTo(x + JOINT_WIDTH * 0.5 * deg_cos +JOINT_LENGTH * deg_sin ,  y + JOINT_WIDTH  * 0.5 * deg_sin - JOINT_LENGTH * deg_cos);
			ctx.lineTo(x - JOINT_WIDTH * 0.5 * deg_cos +JOINT_LENGTH * deg_sin  ,  y - JOINT_WIDTH  * 0.5 * deg_sin - JOINT_LENGTH * deg_cos);
			ctx.lineTo(x - JOINT_WIDTH * 0.5 * deg_cos  ,  y - JOINT_WIDTH  * 0.5 * deg_sin );
			ctx.fill();
		}

		ctx.beginPath();
		ctx.lineWidth = 1;
		ctx.strokeStyle = 'rgb(0, 0, 0)';

		ctx.moveTo(x + BASE_WIDTH  * 0.5 * deg_cos  ,  y + BASE_WIDTH   * 0.5 * deg_sin );
		ctx.lineTo(x + JOINT_WIDTH * 0.5 * deg_cos  ,  y + JOINT_WIDTH  * 0.5 * deg_sin );
		ctx.lineTo(x + JOINT_WIDTH * 0.5 * deg_cos +JOINT_LENGTH * deg_sin ,  y + JOINT_WIDTH  * 0.5 * deg_sin - JOINT_LENGTH * deg_cos);
		ctx.lineTo(x - JOINT_WIDTH * 0.5 * deg_cos +JOINT_LENGTH * deg_sin  ,  y - JOINT_WIDTH  * 0.5 * deg_sin - JOINT_LENGTH * deg_cos);
		ctx.lineTo(x - JOINT_WIDTH * 0.5 * deg_cos  ,  y - JOINT_WIDTH  * 0.5 * deg_sin );
		ctx.lineTo(x - BASE_WIDTH  * 0.5 * deg_cos  ,  y - BASE_WIDTH   * 0.5 * deg_sin );

		ctx.stroke();
		
//		minX = Math.min(minX, endX);
//		maxX = Math.max(maxX, endX);
//		minY = Math.min(minY, endY);
//		maxY = Math.max(maxY, endY);
	}

	function drawRect(x,y,w,h){
	ctx.beginPath();
	ctx.lineWidth = 1;
	ctx.strokeStyle = 'rgb(0, 0, 0)';

	ctx.strokeRect(x,y,w,h);
	ctx.stroke();
	}
	
	
	//直線レール描画
    function drawStraight(x,y,angle,ratio,id) {
		const sinalpha = BASE_LENGTH * ratio * Math.sin(angle * Math.PI/180);
		const cosalpha = BASE_LENGTH * ratio * Math.cos(angle * Math.PI/180);
               	

		for (var i = 0; i < 4; i++) {
                ctx.strokeStyle = colorArray[i];
				ctx.lineWidth = lineWidthArray[i];
				ctx.beginPath();
				ctx.moveTo(x,y);
				ctx.lineTo(x +sinalpha,  y - cosalpha);
				ctx.stroke();
		}
		
		
				drawJoint(x,y,angle);
				drawJoint(x +sinalpha,  y - cosalpha, angle,1);
                ctx.fillStyle = 'white';
                ctx.fillText(id.toString(), x+sinalpha*0.5-5 , y - cosalpha*0.5+3);
	}

	//直線レールの終点を計算
	function CalcStraightEnd(x,y,angle,ratio){
			const sinalpha = BASE_LENGTH * ratio * Math.sin(angle * Math.PI/180);
			const cosalpha = BASE_LENGTH * ratio * Math.cos(angle * Math.PI/180);
			eX = x + sinalpha;
			eY = y - cosalpha;
			eA = angle;
			return [eX,eY,eA];
	}	

	function drawArc(cx, cy, r, sa, ea, boo) {
		ctx.beginPath();
		ctx.arc(cx, cy, r, sa, ea, boo);
		ctx.stroke();
	}


	//曲線レール描画
    function drawCurve(x,y,angle,type,ratio,id) {
		let sinalpha = BASE_LENGTH * ratio * Math.sin(angle * Math.PI/180);
		let cosalpha = BASE_LENGTH * ratio * Math.cos(angle * Math.PI/180);
		let drawColorArray =[];
		switch(type){
			case 'R': case 'L':
			drawColorArray = colorArray;break;
			case 'G': case 'N':
			drawColorArray = colorArray2;break;
		}

		switch(type){ 
			case "R": case "G":{
			const startangle = Math.PI+ angle * Math.PI/180;
			const endangle   = Math.PI*0.25 + startangle;	
			const midangle   = Math.PI*0.125+ startangle;
				for (var i = 0; i < 4; i++) {
                ctx.strokeStyle = drawColorArray[i];
				ctx.lineWidth = lineWidthArray[i];
				ctx.beginPath();
               	ctx.arc(x + cosalpha ,y + sinalpha , BASE_LENGTH * ratio, startangle, endangle);
				ctx.stroke();
				}
			const x2 = x + cosalpha + BASE_LENGTH * ratio * Math.cos(endangle);
			const y2 = y + sinalpha + BASE_LENGTH * ratio * Math.sin(endangle);
			drawJoint(x,y,angle);
			drawJoint(x2,y2,angle+45,1);

			const x3 = x + cosalpha + BASE_LENGTH * ratio * Math.cos(midangle);
			const y3 = y + sinalpha + BASE_LENGTH * ratio * Math.sin(midangle);
                ctx.fillStyle = 'white';
                ctx.fillText(id.toString(), x3-5 , y3+3);
				}

			break;
			
			case "L":case "N":{

			const startangle = angle * Math.PI/180;
			const endangle   = startangle - Math.PI*0.25;	
			const midangle   = startangle - Math.PI*0.125;
				for (let i = 0; i < 4; i++) {
                ctx.strokeStyle = drawColorArray[i];
				ctx.lineWidth = lineWidthArray[i];
				ctx.beginPath();
              	ctx.arc(x - cosalpha ,y - sinalpha , BASE_LENGTH * ratio, startangle, endangle,1);
				ctx.stroke();
				}
			const x2 = x - cosalpha + BASE_LENGTH * ratio * Math.cos(endangle);
			const y2 = y - sinalpha + BASE_LENGTH * ratio * Math.sin(endangle);
			drawJoint(x,y,angle);
			drawJoint(x2,y2,angle-45,1);

			const x3 = x - cosalpha + BASE_LENGTH * ratio * Math.cos(midangle);
			const y3 = y - sinalpha + BASE_LENGTH * ratio * Math.sin(midangle);
	            ctx.fillStyle = 'white';
                ctx.fillText(id.toString(), x3-5 , y3+3);
			break;}
            }    //ctx.fillText(id.toString(), x + 5,y - 40);

		}
//カーブの端点を計算
	function CalcCurveEnd(x,y,angle,type,ratio){
		let sinalpha = BASE_LENGTH * ratio * Math.sin(angle * Math.PI/180);
		let cosalpha = BASE_LENGTH * ratio * Math.cos(angle * Math.PI/180);

		switch(type){
		case 'R':case 'G': 
			var startangle = Math.PI+ angle * Math.PI/180;
			var endangle   = Math.PI * 0.25 + startangle;	
			eX = x + cosalpha + BASE_LENGTH * ratio * Math.cos(endangle);
			eY = y + sinalpha + BASE_LENGTH * ratio * Math.sin(endangle);
			eA = addDeg(angle, 45);
			break;
		case 'L':case 'N':
				startangle = angle * Math.PI/180;
				endangle   = startangle - Math.PI*0.25;	
			eX = x - cosalpha + BASE_LENGTH * ratio * Math.cos(endangle);
			eY = y - sinalpha + BASE_LENGTH * ratio * Math.sin(endangle);
			eA = addDeg(angle, - 45);
			break;
		}
		return [eX,eY,eA];
	}

//スライドレールの描画

	//スライドコース 右ずれ幅割合を正
	function drawSlideRail(sx,sy,angle, rail_ratio, slide_ratio,mode,id){//mode 0:計算のみ、1:描画、2:位置判定

		const deg_sin =  Math.sin(angle * Math.PI / 180.0);
		const deg_cos =  Math.cos(angle * Math.PI / 180.0);

		const ex = sx + rail_ratio * BASE_LENGTH * deg_sin + slide_ratio * BASE_LENGTH * deg_cos;
		const ey = sy - rail_ratio * BASE_LENGTH * deg_cos + slide_ratio * BASE_LENGTH * deg_sin;

	if(mode == 1){//描画関連
		const s1x = sx + 0.5 * rail_ratio * BASE_LENGTH * deg_sin ;
		const s1y = sy - 0.5 * rail_ratio * BASE_LENGTH * deg_cos ;

		const e1x = sx + 0.5 * rail_ratio * BASE_LENGTH * deg_sin + slide_ratio * BASE_LENGTH * deg_cos;
		const e1y = sy - 0.5 * rail_ratio * BASE_LENGTH * deg_cos + slide_ratio * BASE_LENGTH * deg_sin;

		
			for (var i = 0; i < 4; i++) {
				ctx.lineWidth = lineWidthArray[i];
				ctx.strokeStyle = colorArray[i];

				ctx.beginPath();
				ctx.moveTo(sx, sy);
				ctx.bezierCurveTo(s1x, s1y, e1x, e1y, ex, ey);
//				ctx.lineTo(s1x, s1y);
//				ctx.lineTo(e1x, e1y);
//				ctx.lineTo(ex, ey);
				ctx.stroke();
			}
			drawJoint(sx,sy,angle);
			drawJoint(ex,ey,angle,1);

	            ctx.fillStyle = 'white';
                ctx.fillText(id.toString(), (s1x+e1x)/2-5 , (s1y+e1y)/2+3);

		
		}
		return [ex,ey,angle];
	}

//
	// Uターンレール(右）	   
	function drawURCurveRail(sx,sy,angle,type,mode,id,PointX,PointY) {//URAIL_RADIUS_RATIO mode:0終点計算、1描画、2タッチ判定
		const a = type =='V'?-1:1;
		const b = type =='V'? 0:1;
		const c = type =='V'? 1:0;
		
	
		//angle -= 90; 
		var deg_sin = Math.sin(angle * Math.PI / 180.0);
		var deg_cos = Math.cos(angle * Math.PI / 180.0);

		
		if(mode ==1 || mode ==2){
		//Aパーツ
		var c1x = sx + BASE_LENGTH *( URAIL_CNCT_R_RATIO + c* DOUBLE_TRACK_DISTANCE_RATIO  )* deg_cos;
		var c1y = sy + BASE_LENGTH *( URAIL_CNCT_R_RATIO + c* DOUBLE_TRACK_DISTANCE_RATIO  )* deg_sin;
		var s1a = (angle + 180 ) * Math.PI / 180.0;
		var e1a = (angle + 225 ) * Math.PI / 180.0;
		
		//Bパーツ
		var c2x = sx + BASE_LENGTH * ((URAIL_RADIUS_RATIO + URAIL_CNCT_R_RATIO )* Math.sqrt(0.5) * deg_sin - a* DOUBLE_TRACK_DISTANCE_RATIO / 2 * deg_cos  );
		var c2y = sy - BASE_LENGTH * ((URAIL_RADIUS_RATIO + URAIL_CNCT_R_RATIO )* Math.sqrt(0.5) * deg_cos + a* DOUBLE_TRACK_DISTANCE_RATIO / 2 * deg_sin  );
		var s2a = (angle - 225) * Math.PI / 180.0;
		var e2a = (angle + 45) * Math.PI / 180.0;


		//Cパーツ
		var c3x = sx - BASE_LENGTH *( URAIL_CNCT_R_RATIO + b* DOUBLE_TRACK_DISTANCE_RATIO )* deg_cos;
		var c3y = sy - BASE_LENGTH *( URAIL_CNCT_R_RATIO + b* DOUBLE_TRACK_DISTANCE_RATIO )* deg_sin;
		var s3a = (angle    ) * Math.PI / 180.0;
		var e3a = (angle- 45) * Math.PI / 180.0;

		var a1 = BASE_LENGTH * URAIL_CNCT_R_RATIO * 0.5;
		var b1 = BASE_LENGTH * URAIL_CNCT_R_RATIO * 0.2 * a ;
		}
		
		var d1 = BASE_LENGTH * a* DOUBLE_TRACK_DISTANCE_RATIO;



		if(mode == 1){
				ctx.lineWidth = lineWidthArray[0];
				ctx.strokeStyle = colorArray5[1];
				ctx.fillStyle   = colorArray5[1];
				drawArc(c2x, c2y, BASE_LENGTH * URAIL_RADIUS_RATIO , e2a, s2a, false); 
				
				
				ctx.beginPath();
				ctx.moveTo(sx, sy);
				ctx.lineTo(sx + a1 * deg_sin + b1 * deg_cos , sy -a1 * deg_cos + b1 * deg_sin);
				ctx.lineTo(sx + a1 * deg_sin -(b1 + d1) * deg_cos , sy -a1 * deg_cos -(b1+ d1) * deg_sin);
				ctx.lineTo(sx - d1 * deg_cos , sy - d1 * deg_sin);
				ctx.closePath();
				ctx.fill();

			for (var i = 0; i < 4; i++) {
				ctx.lineWidth = lineWidthArray[i];
				ctx.strokeStyle = colorArray5[i];
				drawArc(c2x, c2y, BASE_LENGTH * URAIL_RADIUS_RATIO , s2a, e2a, false); 
				drawArc(c1x, c1y, BASE_LENGTH * URAIL_CNCT_R_RATIO , s1a, e1a, false); 
				drawArc(c3x, c3y, BASE_LENGTH * URAIL_CNCT_R_RATIO , e3a, s3a, false); 
			}
		}else if(mode ==2){
		console.log([s1a/Math.PI * 180.0,e1a/Math.PI * 180.0,s2a/Math.PI * 180.0,e2a/Math.PI * 180.0,s3a/Math.PI * 180.0,e3a/Math.PI * 180.0]);
				//drawArc(c2x, c2y, BASE_LENGTH * URAIL_RADIUS_RATIO , s2a, e2a, false); 
				//drawArc(c1x, c1y, BASE_LENGTH * URAIL_CNCT_R_RATIO , s1a, e1a, false); 
				//drawArc(c3x, c3y, BASE_LENGTH * URAIL_CNCT_R_RATIO , e3a, s3a, false); 
			if(IsPointOnArrow(PointX,PointY,c2x, c2y,0, 359,BASE_LENGTH * URAIL_RADIUS_RATIO ,BASE_WIDTH,0))return true;
			if(IsPointOnArrow(PointX,PointY,c3x, c3y,s3a/Math.PI * 180.0, e3a/Math.PI * 180.0,BASE_LENGTH * URAIL_CNCT_R_RATIO ,BASE_WIDTH,false))return true;
			if(IsPointOnArrow(PointX,PointY,c1x, c1y,s1a/Math.PI * 180.0, e1a/Math.PI * 180.0,BASE_LENGTH * URAIL_CNCT_R_RATIO ,BASE_WIDTH,1))return true;
			
			return false;		
		
		}

		


	//	minX = Math.min(minX, c2x - BASE_LENGTH * URAIL_RADIUS_RATIO);
	//	maxX = Math.max(maxX, c2x + BASE_LENGTH * URAIL_RADIUS_RATIO);
	//	minY = Math.min(minY, c2y - BASE_LENGTH * URAIL_RADIUS_RATIO);
	//	maxY = Math.max(maxY, c2y + BASE_LENGTH * URAIL_RADIUS_RATIO);

		ex = sx - d1 * deg_cos;
		ey = sy - d1 * deg_sin;
		eA = addDeg(angle,180);
		if(mode ==1){
		drawJoint(sx,sy,angle);
		drawJoint(ex,ey,angle);}
		return [ex,ey,eA];

	}




        // 描画
    function draw() {
		canvasSetScale();
        ctx.clearRect(0 - canvasOffsetX/drawScale, 0 - canvasOffsetY/drawScale, canvas.width/drawScale, canvas.height/drawScale);
			
 

	    rails.forEach(rail => {switch(rail.type){
			case 'S':
				drawStraight(rail.x, rail.y, rail.angle,1,rail.id); break;
			case 'R':
				drawCurve(rail.x, rail.y,rail.angle,'R',1,rail.id); break;
			case 'L':
				drawCurve(rail.x, rail.y,rail.angle,'L',1,rail.id); break;
			case 'G':
				drawCurve(rail.x, rail.y,rail.angle,'G',1+DOUBLE_TRACK_DISTANCE_RATIO,rail.id); break;
			case 'N':
				drawCurve(rail.x, rail.y,rail.angle,'N',1+DOUBLE_TRACK_DISTANCE_RATIO,rail.id); break;
			case 'H':
				drawStraight(rail.x, rail.y, rail.angle,0.5
				,rail.id); break;
			case 'Q':
				drawStraight(rail.x, rail.y, rail.angle,0.25,rail.id); break;
			case 'D':
				drawStraight(rail.x, rail.y, rail.angle,2,rail.id); break;
//"U"：Uターン（右）"V"：Uターン（左）"A"：複線幅（右）C：複線幅（左）X：Y字幅（右）"Z"：Y字幅（左）
			case 'A':
				drawSlideRail(rail.x, rail.y, rail.angle, 1.0,  DOUBLE_TRACK_DISTANCE_RATIO,1,rail.id); break;
			case 'C':
				drawSlideRail(rail.x, rail.y, rail.angle, 1.0, -DOUBLE_TRACK_DISTANCE_RATIO,1,rail.id); break;
			case 'X':
				drawSlideRail(rail.x, rail.y, rail.angle, 1.0,  0.25,1,rail.id); break;
			case 'Z':
				drawSlideRail(rail.x, rail.y, rail.angle, 1.0, -0.25,1,rail.id); break;
			case 'U': case'V':
				drawURCurveRail(rail.x, rail.y, rail.angle,rail.type,1,rail.id,0,0); break;
			
			default:

			}
	    });
		
    if(iConpane)drawRect(-166,-333,333,667);
	if(showArrowSet){
		drawArrowset(endX,endY,endAngleDeg);
		//ジョイント配列の確認
		showAllJoints();
		}
    
//	drawURCurveRail(-100,0,0,1)
//	drawURCurveRail(0,0,60,1)
	}


  function draw_interval(){
    clearTimeout(setTOdrawID);
    setTOdrawID=setTimeout(draw,15);

  }


//タッチパネル	スタート
	function onTouchstart(ev) {
		const e = ev.changedTouches[0];
		dfx= 0; dfy=0;
		
		if (ev.touches.length <= 1) {
	
			onMouseStart(e);

    // 指2本の2本の指のＸ座標の差とＹ座標の差を加えた値を記録
		} else if (ev.touches.length >= 2) {
			var p1 = ev.touches[0];
			var p2 = ev.touches[1];
			prePinchDist = Math.sqrt((p1.pageX - p2.pageX)*(p1.pageX - p2.pageX) +(p1.pageY - p2.pageY)*(p1.pageY - p2.pageY));
			preScale = drawScale;
		}
		
		if(!touchcount){touchcount++;
			setTimeout(function(){touchcount=0;},600);
		}else{
			dbcickprocess(preMouseX,preMouseY);
			touchcount=0;
		}



	}

	function onMouseStart(e) {//タッチの挙動をマウスにさせるテスト用
		const rect = canvas.getBoundingClientRect();
			preMouseX = (e.clientX - canvasOffsetX - rect.left);
			preMouseY = (e.clientY - canvasOffsetY - rect.top );
			onMouseprocess(preMouseX,preMouseY);
	
	}

	function onMouseprocess(preMouseX,preMouseY){
	    const mouseX = preMouseX/drawScale;
        const mouseY = preMouseY/drawScale;
			selectedRail = rails.slice().reverse().find(rail =>	isPointOnRail(mouseX, mouseY, rail.x , rail.y,rail.angle, rail.type) );
			if(selectedRail){
                dfx = selectedRail.x - mouseX;
                dfy = selectedRail.y - mouseY;
				showArrowSet = true;
			}
			if(!selectedRail){isDraggingCanvas = true;}
			if(showArrowSet){
				isPointOnJointMark(mouseX,mouseY);
				CheckArrowset(mouseX,mouseY,endX,endY,endAngleDeg);
			}
	}


  function onMouseMove(e) {
		var rect = canvas.getBoundingClientRect();
		var x = e.clientX - canvasOffsetX - rect.left;
		var y = e.clientY - canvasOffsetY - rect.top;

      // 指1本の移動距離に応じて画像の左上の座標を算出
 		const newX = x - preMouseX;
		const newY = y - preMouseY;


        if (selectedRail) {
                selectedRail.x += newX/drawScale;
                selectedRail.y += newY/drawScale;
				
				
				preMouseX = x;
				preMouseY = y;

        }
  

		if (isDraggingCanvas) {
        // キャンバス全体を移動
			ctx.translate(newX,newY);
			canvasOffsetX += newX;
			canvasOffsetY += newY;
		}



  		draw();

    }

	// マウスダブルクリック時の処理
	function onDblClick(e){
        const mouseX = e.clientX - canvasOffsetX - canvas.getBoundingClientRect().left;
        const mouseY = e.clientY - canvasOffsetY - canvas.getBoundingClientRect().top;
		dbcickprocess(mouseX,mouseY);
    }

	function dbcickprocess(mouseX,mouseY){
		console.log(mouseX+","+mouseY);
        rails.forEach((rail,index) =>{//
                if (isPointOnRail(mouseX, mouseY,rail.x,rail.y,rail.angle,rail.type)) {
                    console.log(rail.id);
					rails.splice(index, 1); // 長方形を配列から取り除く
					joints = joints.filter(joint => joint.id != rail.id);
				}
		});
		showArrowSet = false;
		draw();



	}



    // マウス移動時の処理
	function onDrag(e) {
           if (selectedRail) {
                selectedRail.x += e.movementX/drawScale;
                selectedRail.y += e.movementY/drawScale;
               draw();
            }
  

		if (isDraggingCanvas) {
			const newX = e.movementX;
			const newY = e.movementY;
        // キャンバス全体を移動
			ctx.translate(newX,newY);
			canvasOffsetX += newX;
			canvasOffsetY += newY;
			draw();
	//console.log(newX);
		}

		
    }
	
    // マウスアップ時の処理
	function onDragEnd(){
				if(selectedRail){
					const selectedJoint = joints.find(joint => isPointClose(selectedRail.x,selectedRail.y,selectedRail.id,joint.x,joint.y,joint.id,CONECT_LIMIT_D));
					if(selectedJoint){//console.log(selectedJoint);console.log(selectedRail.id);
						
					    if(	selectedRail.x != selectedJoint.x && selectedRail.y != selectedJoint.y){
							selectedRail.angle = selectedJoint.angle;//draw();
							selectedRail.x = selectedJoint.x;
							selectedRail.y = selectedJoint.y;
						}
					}else{
					let xe2;
					let ye2;
					let angle2;
					[xe2,ye2,angle2] = CalcRailEnd(selectedRail.x,selectedRail.y,selectedRail.angle,selectedRail.type);
					const selectedJoint2 = joints.find(joint => isPointClose(xe2,ye2,selectedRail.id,joint.x,joint.y,joint.id,CONECT_LIMIT_D));
					if(selectedJoint2){
						if(selectedJoint2.angle == addDeg(angle2,180)){
							const dfex = selectedJoint2.x - xe2;
							const dfey = selectedJoint2.y - ye2;
							selectedRail.x += dfex;
							selectedRail.y += dfey;
							console.log(selectedJoint2);
							}
									
						}
					
					}
						
					[endX,endY,endAngleDeg] = CalcRailEnd(selectedRail.x,selectedRail.y,selectedRail.angle,selectedRail.type);
					renewJointCoord(selectedRail.id,selectedRail.x,selectedRail.y,selectedRail.angle);
					//console.log(joints);
					draw();LastselectedRail = selectedRail;
				}
 		
		//選択したフラグの解除
	    selectedRail = null;
		selectedJoint = null;

//alert("ofset="+canvasOffsetX + " pre="+ preMouseX);


	    dfx = 0;
	    dfy = 0;

		isDraggingCanvas = null;

	}
    
//マウスホイール
	function onWheel(e){
   		 const scaleFactor = e.deltaY > 0 ? -0.1 : 0.1;
		 console.log(scaleFactor);
 		 drawScale += scaleFactor;
		 //canvasOffsetX -= scaleFactor * canvasOffsetX;
		 //canvasOffsetY -= scaleFactor * canvasOffsetY*drawScale;
		 
		 //scale += scaleFactor;
    	 //drawScale *= scale;
    // キャンバス全体を拡大縮小
 	//	   ctx.scale(scale,scale);
		draw();
	}



//タッチパネル関連
  function onTouchMove(ev) {
		ev.preventDefault();     // デフォルトイベントをキャンセル
		var e = ev.changedTouches[0];

		var rect = canvas.getBoundingClientRect();
		var x = e.clientX - canvasOffsetX - rect.left;
		var y = e.clientY - canvasOffsetY - rect.top;

		var p1 = ev.touches[0];
      // 指1本の移動距離に応じて画像の左上の座標を算出
      if (ev.touches.length <= 1) {

			const newX = x - preMouseX;
			const newY = y - preMouseY;


        if (selectedRail) {
                selectedRail.x += newX/drawScale;
                selectedRail.y += newY/drawScale;
				
				
				preMouseX = x;
				preMouseY = y;

        }
  

		if (isDraggingCanvas) {
        // キャンバス全体を移動
			ctx.translate(newX,newY);
			canvasOffsetX += newX;
			canvasOffsetY += newY;
		}



  		draw();

      // 指2本の指の間の距離に応じて拡大・縮小率を算出
    } else if(ev.touches.length <= 2) {
			
			const p1 = ev.touches[0];
			const p2 = ev.touches[1];
			const dist = Math.sqrt((p1.pageX - p2.pageX)*(p1.pageX - p2.pageX) + (p1.pageY - p2.pageY)*(p1.pageY - p2.pageY));

			drawScale = preScale * dist/prePinchDist;

 // draw_interval();          //
			draw();

      }

//		e.preventDefault();
	}

	

//レールが移動したときに、ジョイントの座標を更新する関数
	function renewJointCoord(Rail_id,x1,y1,angle1){
		const targetJoint = joints.filter(joint => joint.id == Rail_id);
	//	console.log(targetJoint);
		targetJoint[0].x = x1;
		targetJoint[0].y = y1;
		targetJoint[0].angle = addDeg(angle1,-180);
		
		targetJoint[1].x = endX;
		targetJoint[1].y = endY;
		targetJoint[1].angle = endAngleDeg;
	}

//ジョイントの座標をすべて更新する関数
	function renewAllJointCoord(){
		joints = [];
	    rails.forEach((rail) =>{console.log(rail.id);
		rail.angle = rail.angle % 360;
		let joint2 = [];
		const opp_angle = addDeg(rail.angle, -180);
		const joint1 = {x:rail.x,y:rail.y,angle:opp_angle,id:rail.id,j_id:0};
		joints.push(joint1);
	//	switch(rail.type){
	//	case 'S':
// if rail.type S
			[endX,endY,endAngleDeg] = CalcRailEnd(rail.x,rail.y,rail.angle,rail.type);
			joint2 = {x:endX,y:endY,angle:endAngleDeg,id:rail.id,j_id:1};
//			break;




//		default:	
//		}

		joints.push(joint2);

		});
	
	console.log(joints);
	console.log(rails);

	}

//
	function addDeg(a, b){
	return (a + b +360) % 360;
	}

//点の距離がリミット以内かつ同じIDでないかを探す関数
	function isPointClose(x1,y1,id1,x2,y2,id2,dlim){
		const dx = x1 - x2;
		const dy = y1 - y2;
	//console.log("id1="+ id1 + " id2 = "+ id2 );
		if(id1 == id2) return 0;
		return (Math.sqrt(dx**2 + dy**2)<dlim);
	}
		
		

//点がレール上にあるかどうかを判定する関数
	function isPointOnRail(pointX,pointY,x,y,angle,type){
		
		switch(type){
		case 'S':
			return isPointInRectangle(pointX, pointY,x,y,angle,  BASE_LENGTH ); break;
		case 'R':
			return isPointInArc(pointX, pointY, x, y, angle,type, BASE_LENGTH); break;
		case 'L':
			return isPointInArc(pointX, pointY, x, y, angle,type,  BASE_LENGTH); break;
		case 'G':case 'N':
			return isPointInArc(pointX, pointY, x, y, angle,type,  BASE_LENGTH * (1 + DOUBLE_TRACK_DISTANCE_RATIO)); break;
		case 'H':
			return isPointInRectangle(pointX, pointY,x,y,angle,  BASE_LENGTH * 0.5 ); break;
		case 'Q':
			return isPointInRectangle(pointX, pointY,x,y,angle,  BASE_LENGTH * 0.25); break;
		case 'D':
			return isPointInRectangle(pointX, pointY,x,y,angle,  BASE_LENGTH * 2); break;
//"U"：Uターン（右）"V"：Uターン（左）"A"：複線幅（右）C：複線幅（左）X：Y字幅（右）"Z"：Y字幅（左）
		case 'A':
			return isPointOnBelt(pointX, pointY,x,y,angle,1,DOUBLE_TRACK_DISTANCE_RATIO); break;
		case 'C':
			return isPointOnBelt(pointX, pointY,x,y,angle,1,-DOUBLE_TRACK_DISTANCE_RATIO); break;
		case 'X':
			return isPointOnBelt(pointX, pointY,x,y,angle,1,0.25); break;
		case 'Y':
			return isPointOnBelt(pointX, pointY,x,y,angle,1,-0.25); break;
		case 'U':case 'V':
			return drawURCurveRail(x,y,angle,type,2,0,pointX,pointY); break;


		default:return 0;
		}
	}

//タッチ点がジョイント矢印の上にあるかどうか
	function isPointOnJointMark(pointX,pointY){
			 setTimeout(function(){
	         joints.forEach((joint,index) =>{//console.log(rail.id);
				const sx = joint.x + 14 * Math.cos(joint.angle *Math.PI/180);
				const sy = joint.y + 14 * Math.sin(joint.angle *Math.PI/180);
                if (isPointInRectangle(pointX, pointY,sx,sy,joint.angle, 20)) {
                    //console.log(index);
					endX = joint.x;
					endY = joint.y;
					endAngleDeg = joint.angle;draw();return true;
				}
		});
		},500);
	}

	// 点が直線上にあるかどうかを判定する関数
	function isPointInRectangle(pointX, pointY,sx,sy,angle, radius){
	//起点（sx,sy)から長さradiusで引かれた直線上に（pointX,pointY)があるか
//		const radius = radius2 * drawScale;
		const a =   radius * Math.sin( angle * Math.PI/180);
		const b = - radius * Math.cos( angle * Math.PI/180);
		const r2 =  radius * radius ;
		const tt = -(a*  (sx - pointX) + b * (sy - pointY));
		const f1 =   a * (sy - pointY) - b * (sx - pointX);
		const distance2 = BASE_WIDTH * BASE_WIDTH * 0.25  *0.9; 
		return tt>0 && tt< r2 && (f1 * f1)/r2 < distance2;
	}

	// 点が直線上にあるかどうかを判定する関数
	function isPointOnBelt(pointX, pointY,sx,sy,angle,rail_ratio,slide_ratio){
	//起点（sx,sy)からベクトル(a,b)に引かれた直線上に（pointX,pointY)があるか
		const deg_sin =  Math.sin(angle * Math.PI / 180.0);
		const deg_cos =  Math.cos(angle * Math.PI / 180.0);
		
		const a =   rail_ratio * BASE_LENGTH * deg_sin + slide_ratio * BASE_LENGTH * deg_cos;
		const b = - rail_ratio * BASE_LENGTH * deg_cos + slide_ratio * BASE_LENGTH * deg_sin;
		const r2 =  a**2 + b**2 ;
		const tt = -(a*  (sx - pointX) + b * (sy - pointY));
		const f1 =   a * (sy - pointY) - b * (sx - pointX);
		const distance2 = BASE_WIDTH * BASE_WIDTH * 0.25  *0.9; 
		return tt>0 && tt< r2 && (f1 * f1)/r2 < distance2;
	}

        // 点が曲線レール上にあるかどうかを判定する関数(R)
	function isPointInArc(PointX, PointY, arcX, arcY,angle,type, radius) {
			let a  ;
			let rtdr;
			switch(type){
			case'R':case'G':
			a =1;rtdr = 0;
			break;
			case 'L':case 'N':
			a = -1;rtdr = 1; 	
			break;
			}
            const sinalpha = radius * Math.sin(angle * Math.PI/180);
			const cosalpha = radius * Math.cos(angle * Math.PI/180);
            const x =  arcX + a * cosalpha;
            const y =  arcY + a * sinalpha;
 
			//Rの場合      Lの場合
			//　0 -90 -45　　90 45
			//  45 -45 0    135 90
			//  90 0 45     180 135
			// 180 90 135   -90 -135
			// 270 180 225   0  -45
			const a1 = angle - a * 90;
			const a2 = angle - a * 45;
			return IsPointOnArrow(PointX,PointY,x,y,a1,a2,radius,BASE_WIDTH,rtdr);
		
	}




		

//操作用の矢印をセットで表示させる関数
	function drawArrowset(x,y,angle){
		const r1 = 50;
		const r2 = 40;
		const r3 = 30;
		const s1 = 10;
		const s2 = 15;
		const angle_rad = angle * Math.PI/180;

		const xa = x - Math.sin(angle_rad) * s1;
		const ya = y + Math.cos(angle_rad) * s1;
		const xb = x + r1 * Math.cos( -angle_rad); 
		const yb = y - r1 * Math.sin( -angle_rad);
		const xc = x - r1 * Math.cos( +angle_rad);
		const yc = y - r1 * Math.sin( +angle_rad);

		drawArrow(xa,ya, 60+angle, 120+angle,r3,8,'orange',0);
		drawArrow(xa,ya,-60+angle,-120+angle,r3,8,'orange',1);

		drawArrow(xb,yb,-90+angle,-30+angle,r2,8,'green',0);
		drawArrow(xc,yc, 90+angle, 30+angle,r2,8,'green',1);
		drawStArrow(x,y,angle,50,5,8,'green')

               	//ctx.beginPath();
                //ctx.strokeStyle = 'blue';
				//ctx.lineWidth = 1;
               	//ctx.arc(x  ,y  , r1, 0, Math.PI *2 ,1);
				//ctx.stroke();
	}

//操作用の矢印のタッチをチェックする関数
	function CheckArrowset(PointX,PointY,x,y,angle){
		const r1 = 50;
		const r2 = 40;
		const r3 = 30;
		const s1 = 10;
		const s2 = 15;
		const angle_rad = angle * Math.PI/180;

		const xa = x - Math.sin(angle_rad) * s1;
		const ya = y + Math.cos(angle_rad) * s1;
		const xb = x + r1 * Math.cos( -angle_rad); 
		const yb = y - r1 * Math.sin( -angle_rad);
		const xc = x - r1 * Math.cos( +angle_rad);
		const yc = y - r1 * Math.sin( +angle_rad);

		//drawArrow(xa,ya, 60+angle, 120+angle,r3,8,'orange',0);
		//drawArrow(xa,ya,-60+angle,-120+angle,r3,8,'orange',1);

		//drawArrow(xb,yb,-90+angle,-30+angle,r2,8,'green',0);
		//drawArrow(xc,yc, 90+angle, 30+angle,r2,8,'green',1);
		//drawStArrow(x,y,angle,50,5,8,'green')
		if(IsPointOnArrow(PointX,PointY,xa,ya, 60+angle, 120+angle,r3,8,0)){RotateRail(45);}
		else if(IsPointOnArrow(PointX,PointY,xa,ya,-60+angle,-120+angle,r3,8,1)){RotateRail(-45);}
		else if(IsPointOnArrow(PointX,PointY,xb,yb,-90+angle,-30+angle,r2,20,0)){addRail('R');}
		else if(IsPointOnArrow(PointX,PointY,xc,yc, 90+angle, 30+angle,r2,20,1)){addRail('L');}
		else if(isPointInRectangle(PointX,PointY,x, y,angle, 63)){addRail('S');}
               	//ctx.beginPath();
                //ctx.strokeStyle = 'blue';
				//ctx.lineWidth = 1;
               	//ctx.arc(x  ,y  , r1, 0, Math.PI *2 ,1);
				//ctx.stroke();
	}
//レールの回転
	function RotateRail(degree){
		if(LastselectedRail){
		LastselectedRail.angle = addDeg(LastselectedRail.angle,degree);
		[endX,endY,endAngleDeg] = CalcRailEnd(LastselectedRail.x,LastselectedRail.y,LastselectedRail.angle,LastselectedRail.type);
		renewJointCoord(LastselectedRail.id,LastselectedRail.x,LastselectedRail.y,LastselectedRail.angle);
		draw();
		}
	}


//Jointを可視化させる
	function showAllJoints(){//console.log("clicked");
	    joints.forEach(joint => {
			const sx = joint.x + 14 * Math.cos(joint.angle *Math.PI/180);
			const sy = joint.y + 14 * Math.sin(joint.angle *Math.PI/180);
			if(joint.j_id == 1){
				drawStArrow(sx,sy,joint.angle,6,0,5,'red',1);
			} 
			else {drawStArrow(sx,sy,joint.angle,5,0,6,'green',1);
			}
		
	
	//drawArrow(400,400,0,90,0,8,'red',1);
//	drawArrowset(200,400,0);


		});

//console.log('test');

	}


//操作用の直線矢印を描画する関数
	function drawStArrow(x,y,angle,length,distance,width,color){
	
		const sinalpha1 = distance * Math.sin(angle * Math.PI/180);
		const cosalpha1 = distance * Math.cos(angle * Math.PI/180);
 		const sinalpha2 = (distance+length) * Math.sin(angle * Math.PI/180);
		const cosalpha2 = (distance+length) * Math.cos(angle * Math.PI/180);
              	ctx.beginPath();
                ctx.strokeStyle = color;
		ctx.lineWidth = width;
		ctx.moveTo(x +sinalpha1, y - cosalpha1);
		ctx.lineTo(x +sinalpha2, y - cosalpha2);
		ctx.stroke();

   // 矢印を描画
		const arrowLength = width ; // 矢印の長さ
		const arrowAngle = Math.PI / 3; // 矢印の角度（ラジアン）
		const arrowX = x + (arrowLength + distance+length) * Math.sin(angle * Math.PI/180); // 矢印の先端のx座標
		const arrowY = y - (arrowLength + distance+length) * Math.cos(angle * Math.PI/180); // 矢印の先端のy座標
		ctx.beginPath();
		ctx.moveTo(arrowX, arrowY);
		ctx.lineTo(
			x + sinalpha2+ arrowLength * Math.cos(angle * Math.PI/180), 
			y - cosalpha2+ arrowLength * Math.sin(angle * Math.PI/180)
		);
		ctx.lineTo(
			x + sinalpha2 - arrowLength * Math.cos(angle * Math.PI/180),
			y - cosalpha2 - arrowLength * Math.sin(angle * Math.PI/180)
		);
		ctx.closePath();
		ctx.fillStyle = color;
		ctx.fill();


	}


//操作用の矢印パーツを描画する関数
	function drawArrow(x,y,a1,a2,radius,width,color,RotatDir){
		const startangle =  a1 * Math.PI/180 +1.5* Math.PI;
		const endangle   =  a2 * Math.PI/180 +1.5* Math.PI;
		const p = RotatDir == 0 ? 1:-1;	
               	ctx.beginPath();
                ctx.strokeStyle = color;
				ctx.lineWidth = width;
               	ctx.arc(x  ,y  , radius, startangle, endangle,RotatDir);
				ctx.stroke();
   // 矢印を描画
		const arrowLength = width ; // 矢印の長さ
		const arrowAngle = Math.PI / 3; // 矢印の角度（ラジアン）
		const arrowX = x + radius * Math.sin(a2* Math.PI/180)+ p * arrowLength * Math.cos(a2* Math.PI/180); // 矢印の先端のx座標
		const arrowY = y - radius * Math.cos(a2* Math.PI/180)+ p * arrowLength * Math.sin(a2* Math.PI/180); // 矢印の先端のy座標
		ctx.beginPath();
		ctx.moveTo(arrowX, arrowY);
		ctx.lineTo(
			x + (radius + arrowLength) * Math.sin(a2* Math.PI/180),
			y - (radius + arrowLength) * Math.cos(a2* Math.PI/180)
		);
		ctx.lineTo(
			x + (radius - arrowLength) * Math.sin(a2* Math.PI/180),
			y - (radius - arrowLength) * Math.cos(a2* Math.PI/180)
		);
		ctx.closePath();
		ctx.fillStyle = color;
		ctx.fill();
	}


//操作用の矢印上にポイントがあるか確認する関数
	function IsPointOnArrow(PointX,PointY,x,y,a1,a2,radius,width,RotatDir){
		const dx = PointX - x;
		const dy = PointY - y;
		const r2 = dx * dx + dy *dy;
		const angle_P = Math.atan2(dx,-dy);
	//a1,a2は-180～180
		a1 = (a1+180)%360-180;
		a2 = (a2+180)%360-180; 
		const a1_rad = a1* Math.PI /180;
		const a2_rad = a2* Math.PI /180;
		var IsInAngle = 0;
	//矢印は半円以内と仮定
	//時計回りの場合、a1が180未満、a2が180以上のとき断絶
		if(RotatDir == 0){
			if(a2<a1){IsInAngle = (angle_P < a2_rad) || (angle_P> a1_rad);}
			else{ IsInAngle = (angle_P> a1_rad) && (angle_P < a2_rad);}

		}else{
	//反時計回りの場合a1が180以上、a2が180未満のとき断絶
			if(a2>a1){IsInAngle = (angle_P > a2_rad) || (angle_P< a1_rad);}
			else{ IsInAngle = (angle_P< a1_rad) && (angle_P > a2_rad);}

		}
	 //alert(a1 +"-"+ a2 +"-"+ IsInAngle);
		return r2 > (radius - width/2)**2 && r2 < (radius + width/2)**2 && IsInAngle;
	}

		
	function resizeEvent() {
		let ww = window.innerWidth;
		let wh = window.innerHeight;
		//console.log("ww="+ww + ":wh=" +wh);
　　//縦長画面の場合（デフォルト）
    let leftWidth = ww;
    let mainWidth = ww;

    var btn_height = wh / 16;
    var btn_margin = btn_height * 5.5;
    var btn_width = leftWidth / 4.5;

   if(ww > wh　*　1.2 ){//横長画面の場合
   leftWidth = ww * 1/3;
   mainWidth = ww - leftWidth-50;
   //if(!iFullsizeCanvas){btn_height = btn_height * 2;
   //}
   btn_margin = btn_height *1.5;
   btn_width = leftWidth / 3.6;
   $("#title").css('float', 'right');
   $("body").css('line-height', '180%');
   $("H1,H2").css('display', 'block');
   $("#main").css('float', 'left');
   $('.basic_btn').css('margin', '10px 1px 1px 1px');
   $('.basic_btn2').css('margin', '10px 1px 1px 1px');

  }else{
    $("#title").css('float', 'none');
    $("#main").css('float', 'none');

  }

   if(iFullsizeCanvas){
     btn_margin = btn_height *1.5;
     btn_width = ww / 10;
//     document.webkitRequestFullscreen();
   }else{
//     document.webkitCancelFullScreen();
   }




    $('.basic_btn').css('width', btn_width);
		$('.basic_btn').css('height', btn_height);
		$('.basic_btn').css('font-size', (btn_height * 0.5));
		$('.basic_btn2').css('width', btn_width*1.2);
		$('.basic_btn2,.basic_btn3').css('height', btn_height);
		$('.basic_btn2,.basic_btn3').css('font-size', (btn_height * 0.5));

		btn_width =( mainWidth　-　20) / 8;
		$('.scn_btn').css('width', btn_width);
		$('.scn_btn').css('height', btn_height);
		$('.scn_btn').css('font-size', (btn_height * 0.5));
    $("#main").css("width", mainWidth);
    $("#title").css("width", leftWidth);
    $("#rightmenu").css("width", leftWidth);

    if(iFullsizeCanvas){
      $("#railCanvas").attr("width", ww);
	  $("#railCanvas").attr("height", wh);
      $("#railCanvas").css("position", "fixed");
      $("#railCanvas").css("top", 0);
      $("#railCanvas").css("left", 0);

      $("#btn_R,#btn_S,#btn_L,#close_Full_scr,#btn_b,#btn_rst,#btn_save,#btn_load,#dataSelect").css("position", 'fixed' );
      $("#btn_fr,#btn_nxt2").css("position", 'fixed' );
      $('.basic_btn,.basic_btn2,.basic_btn3').css('height', "");
      $('.basic_btn,.basic_btn2,.basic_btn3').css('width', "");
      var fulsc_font_size = Math.min(wh/20,ww/21);
      $('.basic_btn,.basic_btn2,.basic_btn3').css('font-size', fulsc_font_size);


      $("#btn_R,#btn_S,#btn_L").css("visibility", 'visible' );
      $("#btn_R,#btn_S,#btn_L,#btn_b,#btn_rst").css("top", wh-btn_height*3.5);
      $("#btn_save,#btn_load,#dataSelect").css("top", wh-btn_height*1.5);



      var btngap = ww/26;

      $("#btn_L").css("left", btngap/2);
      $("#btn_S").css("left", btngap/2 + btn_width + btngap);
      $("#btn_R").css("left", btngap/2 + btn_width*2 + btngap*2);

      $("#btn_save").css("left", btngap/2);
      $("#btn_load").css("left", btngap/2 + btn_width + btngap);
      $("#dataSelect").css("left", btngap/2 + btn_width*2 + btngap*2);


      $("#btn_fr").css("left", btngap/2);
      $("#btn_nxt2").css("left", btngap/2 + btn_width + btngap);


      $("#btn_rst").css("right", btngap/4);
      $("#btn_b").css("left", btngap/2 + btn_width*3 + btngap*3);


      $("#close_Full_scr").css("top", 10);
      $("#close_Full_scr").css("right", 10);
      $("#close_Full_scr").attr("value", "X");


      $("#NO_Q,#remain_mss").css("position", "fixed");
      $("#NO_Q").css("top", 10);
      $("#remain_mss").css("top", wh-btn_height*1.5);
      $("#NO_Q").css("left", 10);
      $("#remain_mss").css("left", btngap/2);
      $("#remain_mss,#NO_Q").css('font-size', (btn_height * 0.8));



    }else{//全面じゃない場合
      $("#railCanvas").attr("width", mainWidth-30);
  		$("#railCanvas").attr("height", wh - btn_margin - 20 );

      $("#btn_nxt").css("position", 'absolute' );
      $("#railCanvas,#btn_R,#btn_S,#btn_L,#close_Full_scr,#btn_b,#btn_rst,#btn_save,#btn_load,#dataSelect").css("position", 'static' );
      $("#btn_fr,#btn_nxt2").css("position", 'static' );
      $("#NO_Q,#remain_mss").css("position", "static");
      $("#btn_nxt").css("top", (wh)/2 + btn_height );
      $("#btn_nxt").css("left", mainWidth/2 -btn_width);
      $("#btn_nxt").css("visibility", 'hidden' );
      $("#btn_R,#btn_S,#btn_L").css("top", -btn_height*1.4);
      $("#close_Full_scr").attr("value", "□");
      $("#remain_mss,#NO_Q").css('font-size',"100%");


    }



    $('body').css('font-size', (btn_height * 0.3));

		draw();
	}

  function closeFullscr(){
    if(iFullsizeCanvas){
      iFullsizeCanvas = false;
    }else{
      iFullsizeCanvas = true;
    }
    resizeEvent();
  }

  function show_nxt_buttan(){
    $("#btn_nxt").css("visibility", 'visible' );
  }
  function hide_nxt_buttan(){
    $("#btn_nxt").css("visibility", 'hidden' );

  }

let anotherRouteCount;
let railAnotherRoute;
let anotherRouteStock;
let anotherRouteStockIndex;
let railUnitStack;

// 別コース生成処理	
function genPath() {
	anotherRouteCount = 0;
	railAnotherRoute = new Array();
	anotherRouteStock = new Array();
	anotherRouteStockIndex = 0;

	railUnitStack = new Array();
	railUnitStack = railOriginalRoute.concat(); // 内容のコピー
	RAIL_NUM_MAX = railOriginalRoute.length + 8;
//	if(RAIL_NUM_MAX > 15) RAIL_NUM_MAX= 14;

	
	// debugout
	/*
	var temp = "";
	for(var i = 0; i < railUnitStack.length; i++) {
        temp += "/" + railUnitStack[i].type + ":" + railUnitStack[i].angleIN + ":" + railUnitStack[i].angleOUT;
	}
    console.log("-original---------> " + temp);
	*/
				
	// パスの組み換え
	console.time('timer1');
		
	NextSerchRoute = new Array();
	NextSerchRoute.push( new RailCourse("", endX, endY, endAngleDeg,0) );	



	serchRoute2depth(14);
 
		
	console.timeEnd('timer1');
		
	if(anotherRouteCount == 0) {
		document.getElementById("anotherRailInfo").innerHTML = 
		'<font color="red">別のルートが見つかりませんでした</font>';
	} else {

		railAnotherRoute = anotherRouteStock[0];

		if(anotherRouteCount == ROUTE_NUM_LIMIT) {
			document.getElementById("anotherRailInfo").innerHTML = 
			"検索上限の" + anotherRouteCount + "個の別ルートが見つかりました";
		} else {
			document.getElementById("anotherRailInfo").innerHTML = 
			anotherRouteCount + "個の別ルートが見つかりました";			
		}
	}
	
	updateRouteIndexHTML();
	draw();
}

		
    </script>
	
	
	
</head>
<body onload="init();">
  <div id="title">
  <H1>レール配置</h1>
  
  </div>

  <div id="main">
    <canvas id="railCanvas" width="750" height="750"></canvas>
   </div>
 



<br>  

  <div id="rightmenu">
    <h2>レールの追加:</h2>
    <input id="btn_L" type="button" value="L" onclick="addRail('L');draw();" class="basic_btn" style="center" />
    <input id="btn_S" type="button" value="S" onclick="addRail('S');draw();" class="basic_btn" style="center" />
    <input id="btn_R" type="button" value="R" onclick="addRail('R');draw();" class="basic_btn" style="center" />
 <br/>

    <input id="btn_b" type="button" value="リサイズ" onclick="scaleReset();draw();" class="basic_btn"" />
    <input id="btn_rst" type="button" value="全消" onclick="clearData();" class="scn_btn" /><br/>
    <input id="btn_v" type="button" value="特" onclick="add_SP_Rail('railSelect');draw();" class="scn_btn" style="center" />
	<label class="scn_btn" for="railSelect"></label>
    <select id="railSelect"　class="scn_btn" name="railSelect">
        <option value="G">複線外側（右）</option>
        <option value="N">複線外側（左）</option>
        <option value="U">Uターン（右）</option>
        <option value="V">Uターン（左）</option>
        <option value="A">複線幅（右）</option>
        <option value="C">複線幅（左）</option>
        <option value="X">Y字幅（右）</option>
        <option value="Z">Y字幅（左）</option>
    </select>
<input id="btn_v2" type="button" value="直" onclick="add_SP_Rail('railSelect2');draw();" class="scn_btn" style="center" />
 	<label class="scn_btn" for="railSelect2"></label>
    <select id="railSelect2"　class="scn_btn" name="railSelect2">
        <option value="H">1/2直線</option>
        <option value="Q">1/4直線</option>
        <option value="D">倍直線</option>
        <option value="J">ジョイント</option>
   </select>
<hr>

   <div id="scn_btn_set">
    <input id="btn_save" type="button" value="保存" onclick="save()" class="scn_btn"  style="" />
	<input id="btn_load" type="button" value="読込" onclick="load()" class="scn_btn"  style="" />
	<label class="scn_btn" for="dataSelect">保存スロット</label>
    <select id="dataSelect"　class="scn_btn" name="memoryslot">
        <option value="ringo">りんご</option>
        <option value="mikan">みかん</option>
        <option value="budou">ぶどう</option>
        <option value="banana">バナナ</option>
        <option value="suika">すいか</option>
    </select>
    <p id="output"></p>


<!--    <h2><smapn id="scal"></span></h2> -->
   </div>	


   <h2 id="remain_mss"><span id="message"></span></h2>

   <hr>
<input id="close_Full_scr" type="button" value="□" onclick="closeFullscr();" class="basic_btn"/>:全画面化

<a href="https://x.com/intent/post?hashtags=jmitani_railway_puzzle&ref_src=twsrc%5Etfw&text=%E3%83%AC%E3%83%BC%E3%83%AB%E3%83%91%E3%82%BA%E3%83%AB&tw_p=tweetbutton&url=http%3A%2F%2Fplalayout.html.xdomain.jp%2Frail-simu%2Ftest.htm" id="rslt_tweet" class="twitter-share-button" >ツイート</a></script>
 <div id='copyright'>

 </div>

</div>


</body>
</html>
